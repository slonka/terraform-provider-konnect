// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// Requirements - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Requirements struct {
	// Tags defines set of required tags. You can specify '*' in value to require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *Requirements) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// Restrictions - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Restrictions struct {
	// Tags defines set of required tags. You can specify '*' in value to require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *Restrictions) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// DataplaneProxy - DataplaneProxyMembership defines a set of requirements for data plane proxies to be a member of the mesh.
type DataplaneProxy struct {
	// Requirements defines a set of requirements that data plane proxies must fulfill in order to join the mesh.
	Requirements []Requirements `json:"requirements,omitempty"`
	// Restrictions defines a set of restrictions that data plane proxies cannot fulfill in order to join the mesh.
	Restrictions []Restrictions `json:"restrictions,omitempty"`
}

func (o *DataplaneProxy) GetRequirements() []Requirements {
	if o == nil {
		return nil
	}
	return o.Requirements
}

func (o *DataplaneProxy) GetRestrictions() []Restrictions {
	if o == nil {
		return nil
	}
	return o.Restrictions
}

// Constraints that applies to the mesh and its entities
type Constraints struct {
	// DataplaneProxyMembership defines a set of requirements for data plane proxies to be a member of the mesh.
	DataplaneProxy *DataplaneProxy `json:"dataplaneProxy,omitempty"`
}

func (o *Constraints) GetDataplaneProxy() *DataplaneProxy {
	if o == nil {
		return nil
	}
	return o.DataplaneProxy
}

// Conf - Configuration of the backend
type Conf struct {
}

// Backends - LoggingBackend defines logging backend available to mesh. Backends can be used in TrafficLog rules.
type Backends struct {
	// Configuration of the backend
	Conf *Conf `json:"conf,omitempty"`
	// Format of access logs. Placeholders available on https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log
	Format *string `json:"format,omitempty"`
	// Name of the backend, can be then used in Mesh.logging.defaultBackend or in TrafficLogging
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'tcp' and 'file')
	Type *string `json:"type,omitempty"`
}

func (o *Backends) GetConf() *Conf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *Backends) GetFormat() *string {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *Backends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Backends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Logging settings. +optional
type Logging struct {
	// List of available logging backends
	Backends []Backends `json:"backends,omitempty"`
	// Name of the default backend
	DefaultBackend *string `json:"defaultBackend,omitempty"`
}

func (o *Logging) GetBackends() []Backends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Logging) GetDefaultBackend() *string {
	if o == nil {
		return nil
	}
	return o.DefaultBackend
}

// PutV1MeshControlPlanesCpIDAPIMeshesMeshNameConf - Configuration of the backend
type PutV1MeshControlPlanesCpIDAPIMeshesMeshNameConf struct {
}

// Rotation settings
type Rotation struct {
	// Time after which generated certificate for Dataplane will expire
	Expiration *string `json:"expiration,omitempty"`
}

func (o *Rotation) GetExpiration() *string {
	if o == nil {
		return nil
	}
	return o.Expiration
}

// DpCert - Dataplane certificate settings
type DpCert struct {
	// Timeout on request to CA for DP certificate generation and retrieval
	RequestTimeout *string `json:"requestTimeout,omitempty"`
	// Rotation settings
	Rotation *Rotation `json:"rotation,omitempty"`
}

func (o *DpCert) GetRequestTimeout() *string {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

func (o *DpCert) GetRotation() *Rotation {
	if o == nil {
		return nil
	}
	return o.Rotation
}

// Mode defines the behaviour of inbound listeners with regard to traffic encryption
type Mode string

const (
	ModeStrict     Mode = "STRICT"
	ModePermissive Mode = "PERMISSIVE"
)

func (e Mode) ToPointer() *Mode {
	return &e
}
func (e *Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STRICT":
		fallthrough
	case "PERMISSIVE":
		*e = Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Mode: %v", v)
	}
}

type RootChain struct {
	// Timeout on request for to CA for root certificate chain. If not specified, defaults to 10s.
	RequestTimeout *string `json:"requestTimeout,omitempty"`
}

func (o *RootChain) GetRequestTimeout() *string {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

// PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends - CertificateAuthorityBackend defines Certificate Authority backend
type PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends struct {
	// Configuration of the backend
	Conf *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameConf `json:"conf,omitempty"`
	// Dataplane certificate settings
	DpCert *DpCert `json:"dpCert,omitempty"`
	// Mode defines the behaviour of inbound listeners with regard to traffic encryption
	Mode *Mode `json:"mode,omitempty"`
	// Name of the backend
	Name      *string    `json:"name,omitempty"`
	RootChain *RootChain `json:"rootChain,omitempty"`
	// Type of the backend. Has to be one of the loaded plugins (Kuma ships with builtin and provided)
	Type *string `json:"type,omitempty"`
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends) GetConf() *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends) GetDpCert() *DpCert {
	if o == nil {
		return nil
	}
	return o.DpCert
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends) GetMode() *Mode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends) GetRootChain() *RootChain {
	if o == nil {
		return nil
	}
	return o.RootChain
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Mtls - mTLS settings. +optional
type Mtls struct {
	// List of available Certificate Authority backends
	Backends []PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends `json:"backends,omitempty"`
	// Name of the enabled backend
	EnabledBackend *string `json:"enabledBackend,omitempty"`
	// If enabled, skips CA validation.
	SkipValidation *bool `json:"skipValidation,omitempty"`
}

func (o *Mtls) GetBackends() []PutV1MeshControlPlanesCpIDAPIMeshesMeshNameBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Mtls) GetEnabledBackend() *string {
	if o == nil {
		return nil
	}
	return o.EnabledBackend
}

func (o *Mtls) GetSkipValidation() *bool {
	if o == nil {
		return nil
	}
	return o.SkipValidation
}

// PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequestBody - Mesh defines configuration of a single mesh.
type PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequestBody struct {
	// Constraints that applies to the mesh and its entities
	Constraints *Constraints `json:"constraints,omitempty"`
	// Logging settings. +optional
	Logging *Logging `json:"logging,omitempty"`
	// mTLS settings. +optional
	Mtls *Mtls `json:"mtls,omitempty"`
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequestBody) GetConstraints() *Constraints {
	if o == nil {
		return nil
	}
	return o.Constraints
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequestBody) GetLogging() *Logging {
	if o == nil {
		return nil
	}
	return o.Logging
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequestBody) GetMtls() *Mtls {
	if o == nil {
		return nil
	}
	return o.Mtls
}

type PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequest struct {
	// Id of the Konnect resource
	CpID string `pathParam:"style=simple,explode=false,name=cpId"`
	// Name of the mesh (e.g., default, secondary)
	MeshName    string                                                 `pathParam:"style=simple,explode=false,name=meshName"`
	RequestBody PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequestBody `request:"mediaType=application/json"`
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequest) GetCpID() string {
	if o == nil {
		return ""
	}
	return o.CpID
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequest) GetMeshName() string {
	if o == nil {
		return ""
	}
	return o.MeshName
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequest) GetRequestBody() PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequestBody {
	if o == nil {
		return PutV1MeshControlPlanesCpIDAPIMeshesMeshNameRequestBody{}
	}
	return o.RequestBody
}

type PutV1MeshControlPlanesCpIDAPIMeshesMeshNameResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameResponse) GetContentType() string {
	if o == nil {
		return ""
	}
	return o.ContentType
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameResponse) GetStatusCode() int {
	if o == nil {
		return 0
	}
	return o.StatusCode
}

func (o *PutV1MeshControlPlanesCpIDAPIMeshesMeshNameResponse) GetRawResponse() *http.Response {
	if o == nil {
		return nil
	}
	return o.RawResponse
}
